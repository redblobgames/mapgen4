#+title: Mapgen2, HTML5
#+date: <2017-08-03>

#+begin_export html
<x:draft/>

<style>
  figure { margin-left: 0; margin-right: 0; }
  .hover-term { cursor: help; border-bottom: 2px dashed black; }
  #diagram-mesh-construction button { background-color: hsl(60,10%,90%); }
  #diagram-mesh-construction button.active { background-color: hsl(120,50%,80%); border-color: hsl(120,50%,50%); }
</style>
#+end_export

WIP- recreating the diagrams and algorithms from http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ in html5

#+begin_export html
<div style="clear:both"/>
#+end_export

* Polygons

There are four steps to constructing the polygon mesh we need:

#+begin_export html
<div id="diagram-mesh-construction">
  <figure>
    <figcaption>
      <span v-if="show==='points'">Evenly distributed points</span>
      <span v-else-if="show==='delaunay'">Delaunay triangulation</span>
      <span v-else-if="show==='centroids'">Triangle centroids</span>
      <span v-else-if="show==='polygons'">Polygons</span>
      <span v-else="">Dual mesh</span>
    </figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,centroidCircumcenterMix}"/>
  </figure>
  <ol>
    <li>Pick <span class="hover-term" v-on:mouseover="show='points'">evenly distributed points</span> using Poisson disc (or Lloyd relaxation).</li>
    <li>Construct a <span class="hover-term" v-on:mouseover="show='delaunay'">Delaunay triangulation</span>.</li>
    <li>Calculate the <span class="hover-term" v-on:mouseover="show='centroids'">centroids of the triangles</span>.</li>
    <li>Construct <span class="hover-term" v-on:mouseover="show='polygons'">polygons from those points</span>.</li>
  </ol>
  <p>
    Putting it all together, I have a <span class="hover-term" v-on:mouseover="show=null">dual mesh</span>. The same steps work for Voronoi instead of centroid polygons; compare: Centroid&nbsp;<input type="range" min="0" max="1" step="0.01" v-model.number="centroidCircumcenterMix"/>&nbsp;Voronoi.
  </p>
</div>
#+end_export

{ implementation notes - here or later? }

For evenly distributed red points, I used [[http://devmag.org.za/2009/05/03/poisson-disk-sampling/][Poisson disc sampling]] in this project and [[https://en.wikipedia.org/wiki/Lloyd%2527s_algorithm][Lloyd relaxation]] in a previous project. 

I added points along the boundary of the map with a slight curvature to avoid long skinny Delaunay triangles.

* Map representation

{ should implementation be on a separate page? }

[[http:/x/1722-b-rep-triangle-meshes/][stuff from this page]]

* Islands

I'm generating islands, so the boundary of the map will always be water. In the interior, I can use noise to determine which areas are land and water.

#+begin_export html
<div id="diagram-water-assignment">
  <figure>
    <figcaption v-if="show==='landwater'">Choose polygons that are water vs land</figcaption>
    <figcaption v-else-if="show==='connectivity'">Connectivity from the boundary identifies oceans vs lakes</figcaption>
    <figcaption v-else-if="show==='lakes'">Lakes are water polygons not connected to the boundary</figcaption>
    <figcaption v-else="">Coastline separates oceans from land</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,show,v_water,v_ocean}"/>
    parameters: noisy<input type="range" min="0" max="1" step="0.01" v-model.number="round"/>round ;  
    deflate<input type="range" min="0" max="1" step="0.01" v-model.number="inflate"/>inflate
  </figure>
  <p>
    There are two things we need once we've assigned water vs land:
  </p>
  <ol>
    <li>Use noise to determine <span class="hover-term" v-on:mouseover="show='landwater'">land vs. water</span>.</li>
    <li>Use <span class="hover-term" v-on:mouseover="show='connectivity'">connectivity</span> to determine which water polygons are ocean.</li>
    <li><span class="hover-term" v-on:mouseover="show='lakes'">Lakes</span> are the water polygons not connected to the boundary of the map. <em v-if="lakecount === 0">Try changing the parameters until lakes form.</em></li>
    <li><span class="hover-term" v-on:mouseover="show=null">Coastlines</span> are the edges connected to an ocean polygon on one side and a land polygon on the other.</li>
  </ol>
</div>
#+end_export

{ should I explain the game's needs, so that the reader can pick different algorithms that match their own needs? }

{ implementation notes could include the noise function -- maybe the noisy/deflate parameters could move to a separate diagram to avoid having to explain the lack of lakes in the main list; connectivity is depth first or breadth first search }

* Elevation

For this project I set elevation based on the /distance from the coast/. It's not the right choice for most maps, but it was the right thing for the project I made this for. To calculate it, I'll run Breadth First Search from the coastline. I tried distances on the polygons and distances on the corners, and I found corners worked better for this map generator. 

#+begin_export html
<div id="diagram-elevation-assignment">
  <figure>
    <figcaption v-if="show==='coast_t'">Coastline</figcaption>
    <figcaption v-else-if="show==='v_elevation'">Distance from coastline, corners</figcaption>
    <figcaption v-else="">Distance from coastline, polygons</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,t_elevation,t_coastdistance,v_elevation}"/>
  </figure>
  <ol>
    <li>Find <span class="hover-term" v-on:mouseover="show='coast_t'">corners along coastline edges</span>. As above, coastline edges have an ocean on one side and land on the other side.</li>
    <li>Calculate corner <span class="hover-term" v-on:mouseover="show='t_coastdistance'">distance from the coastline</span> using Breadth First Search.</li>
    <li>Set <span class="hover-term" v-on:mouseover="show='t_elevation'">corner elevation</span> by rescaling ocean distances from -1 to 0 and land distances from 0 to +1.</li>
    <li>Set the <span class="hover-term" v-on:mouseover="show=null">polygon elevation</span> to the average elevation of the polygon's corners.</li>
  </ol>
</div>
#+end_export

** Lakes

If there are no lakes, Breadth First Search works great, but with lakes, things get more complicated. I want the entire lake to have the same corner elevation, so I check if the edge has a lake on either side. If so, I don't increase the distance along that edge. Look at the distance visualization to see this around lakes. This turns breadth first search into a more complicated graph search. I'm not happy with this but it's good enough for now.

** TODO Elevation from noise

Elevation based on distance to coastline produces simplistic symmetric volcanic-style islands. It's what we wanted in our game. There are lots of other ways to set elevation.

** TODO Controlling the distribution

{ show the distribution }

If we have a desired distribution of elevations, we can reshape the distribution. I'm using a linear mapping from distance to elevation but that mapping can be anything.

* Rivers

At each corner, I point to the corner that has the lowest elevation. This forms a drainage map, sometimes called a watershed map.

1. Rivers start on land and flow down to the coastline.
1. Rivers join together (tributaries) but don't fork (distributaries).
1. There are no cycles.

#+begin_export html
<div id="diagram-drainage-assignment">
  <figure>
    <figcaption>Drainage patterns</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,v_elevation,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRiver">Add river</button>
  <button v-on:click="addRiver25">Add 25 rivers</button>
</div>
#+end_export

Rivers follow the drainage map, but for this project, not all drainage channels become rivers. I pick them randomly.

{ implementation: because elevations are based on distances, there are /many/ possible downslope graphs for the same elevations, and which one we calculate depends a lot on the graph traversal order, ick -- this needs to be part of the random seed, maybe using noise or some location based hash }

** Lakes

Along lakes, the elevation isn't increasing, so what should the drainage map do? I make the drainage map follow the graph search used for elevation, so any drainage leading into a lake will eventually lead out, but may take a convoluted path inside the lake. I'm not happy with this but it's good enough for now.

** TODO Watersheds

Drainage can also be used to define watersheds, which can be useful as political and cultural boundaries. Rivers are also useful as political (but not cultural) boundaries.

{ diagram or layer showing watershed boundaries }

** TODO Parameters for selecting a subset of rivers

Not all locations produce equally good rivers. Some filters to consider:

1. Only "leaves" of the drainage tree. (implemented above)
2. Only above some elevation threshold.
3. Only on sloped land. (if you have variable slopes)
4. Only locations with plenty of rainfall. (if you have rainfall implemented)
5. Only locations with wind carrying moisture from bodies of water.
6. Only land that's on a peak not a valley.

* Moisture

I use a “moisture” value to assign biomes in the next section. I set moisture to the /distance/ from a lake or river. The start points are lake polygons and the the polygons adjacent to a river. Similar to elevation, I use Breadth First Search to calculate the distances, then rescale them. Zero distance will have moisture 1.0 and high distance will have moisture 0.0.

#+begin_export html
<div id="diagram-moisture-assignment">
  <figure>
    <figcaption>Moisture</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,v_moisture,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRivers">Add rivers</button>
</div>
#+end_export

There are many other ways to assign moisture/humidity/rainfall. I used this one because it was simple and worked well for the game these maps were for. Consider instead using noise (Perlin, Simplex, etc.) or wind simulation (rain shadows, evapotranspiration, etc.).

** TODO Controlling the distribution

{ show the distribution }

If we have a desired distribution of moisture, we can reshape the distribution. I'm using a sqrt mapping from distance to moisture but that mapping can be anything.

* Biomes

(explanation about whittaker diagrams, indexed with temperature and rainfall -- temperature is based on elevation and latitude, but on a small island the latitude is constant; rainfall is based on evaporation and wind but I'm just using moisture=evaporation here)

#+begin_export html
<div id="diagram-biome-assignment">
  <figure>
    <figcaption>Biomes</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,river_t,e_flow,v_biome}"/>
  </figure>
  <button v-on:click="reset">Reset</button>
  <input type="range" min="0" :max="spring_t.length" v-model.number="numRivers"/> rivers
  <button v-on:click="addRivers">Add rivers</button>
</div>
#+end_export

** TODO Controlling the distribution

{ show the distribution }

See also http://worldengine-ecs.readthedocs.io/en/latest/biomes.html -- it seems useful to draw the scatter plot or a density plot, and then provide parameters for tuning that to make an ice world or a forest world etc.

* Export

#+begin_export html
<div id="map-export">
  <textarea style="width: 100%; height: 10em; border: 3px solid #ccc; padding: 5px; font-family: monospace; overflow: scroll" onclick="this.setSelectionRange(0, this.value.length)" v-model="output"/>
  <button v-on:click="calculate">Export</button>
</div>
#+end_export


* Noisy rendering

** Noisy edges

** Noisy transitions

** Noisy fills

* References


https://heredragonsabound.blogspot.com/

https://m.mythcreants.com/blog/crafting-plausible-maps/

http://www.giantitp.com/articles/xO3dVM8EDKJPlKxmVoG.html


* More

#+begin_export html
  <x:footer>
    <script src="/js/vue.js"/>
    <script src="/js/prng.js"/>
    <script src="_bundle.js"/>

    Created 3 Aug 2017 with <a href="https://vue.org/">Vue.js</a> and Emacs org-mode (<a href="index.org">source of this page</a>); &#160;
    <!-- hhmts start -->Last modified: 17 Aug 2017<!-- hhmts end -->
  </x:footer>
#+end_export
