#+title: Mapgen2, HTML5
#+date: <2017-08-03>

#+begin_export html
<x:draft/>

<style>
  figure { margin-left: 0; margin-right: 0; }
  .hover-term { cursor: help; border-bottom: 2px dashed black; }
  #diagram-mesh-construction button { background-color: hsl(60,10%,90%); }
  #diagram-mesh-construction button.active { background-color: hsl(120,50%,80%); border-color: hsl(120,50%,50%); }
</style>
#+end_export

WIP- recreating the diagrams and algorithms from http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/ in html5

* Polygons

There are four steps to constructing the polygon mesh we need:

#+begin_export html
<div id="diagram-mesh-construction">
  <ol>
    <li><button v-on:click="timeGoal = 0" :class="time &lt; 0.9? 'active':null">Go</button> Pick some evenly distributed points.</li>
    <li><button v-on:click="timeGoal = 1" :class="time &gt;= 0.9 &amp;&amp; time &lt; 1.9? 'active':null">Go</button> Construct the Delaunay triangulation.</li>
    <li><button v-on:click="timeGoal = 2" :class="time &gt;= 1.9 &amp;&amp; time &lt; 2.9? 'active':null">Go</button> Calculate the triangle centroids.</li>
    <li><button v-on:click="timeGoal = 3" :class="time &gt;= 2.9 ? 'active':null">Go</button> Construct polygons from the centroid points.</li>
  </ol>
  <figure>
    <canvas width="600" height="600" v-draw="{mesh,time,centroidCircumcenterMix}"/>
    <figcaption>
      <span v-if="time &lt; 0.9">1. Pick points</span>
      <span v-else-if="time &lt; 1.9">2. Delaunay triangulation</span>
      <span v-else-if="time &lt; 2.9">3. Triangle centroids</span>
      <span v-else="">4. Polygons</span>
      <span v-if="time &gt;= 1.9">&nbsp;&nbsp;(compare: centroid <input type="range" min="0" max="1" step="0.01" v-model.number="centroidCircumcenterMix"/> voronoi)</span>
    </figcaption>
  </figure>
</div>
#+end_export

For evenly distributed red points, I used [[http://devmag.org.za/2009/05/03/poisson-disk-sampling/][Poisson disc sampling]] in this project and [[https://en.wikipedia.org/wiki/Lloyd%2527s_algorithm][Lloyd relaxation]] in a previous project. I added points along the boundary of the map with a slight curvature to avoid long skinny Delaunay triangles. I originally used Voronoi polygons but to more evenly space the blue points, I switched to centroids.

* Map representation

* Islands

I'm generating islands, so the boundary of the map will always be water. In the interior, I can use noise to determine which areas are land and water.

#+begin_export html
<div id="diagram-water-assignment">
  <figure>
    <figcaption v-if="showCoast">Coastline separates oceans from land</figcaption>
    <figcaption v-else-if="showLakes">Lakes are water polygons not connected to the boundary</figcaption>
    <figcaption v-else="">Choose polygons that are water vs land</figcaption>
    <canvas width="600" height="600" v-draw="{mesh,v_water,v_ocean,showLakes,showCoast}"/>
    parameters: noisy<input type="range" min="0" max="1" step="0.01" v-model.number="round"/>round ;  
    deflate<input type="range" min="0" max="1" step="0.01" v-model.number="inflate"/>inflate
  </figure>
  <p>
    There are two things we need once we've assigned water vs land:
  </p>
  <ol>
    <li><span class="hover-term" v-on:mouseover="showLakes=true" v-on:mouseout="showLakes=false">Lakes</span> are the polygons not connected to the boundary of the map. In this map there are {{counts.ocean}} oceans and {{counts.lake}} lakes. <em v-if="counts.lake === 0">Try changing the parameters until lakes form.</em></li>
    <li><span class="hover-term" v-on:mouseover="showCoast=true" v-on:mouseout="showCoast=false">Coastlines</span> are the edges connected to an ocean polygon on one side and a land polygon on the other.</li>
  </ol>
</div>
#+end_export

* Elevation

For this project I set elevation based on the /distance from the coast/. It's not the right choice for most maps, but it was the right thing for the project I made this for. To calculate it, I'll run Breadth First Search from the coastline. I tried distances on the polygons and distances on the corners, and I found corners worked better for this map generator. 

#+begin_export html
<div id="diagram-elevation-assignment">
  <figure>
    <figcaption v-if="show==='coast_t'">Coastline</figcaption>
    <figcaption v-else-if="show==='v_elevation'">Distance from coastline, corners</figcaption>
    <figcaption v-else="">Distance from coastline, polygons</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,t_elevation,v_elevation}"/>
  </figure>
  
  <p>
    To find the start points for breadth first search, I picked <span class="hover-term" v-on:mouseover="show='coast_t'">corners along a coastline edge</span>. As above, coastline edges have an ocean on one side and land on the other side. Once I have <span class="hover-term" v-on:mouseover="show='v_elevation'">distance from the coastline</span> on corners, I need to convert it back to polygons. I chose to set the <span class="hover-term" v-on:mouseover="show=null">polygon elevation</span> to the <code>min()</code> of the corner elevations. The average or max would work as well.
  </p>
</div>
#+end_export

** TODO Handle lakes

** TODO Elevation from noise

Elevation based on distance to coastline produces simplistic symmetric volcanic-style islands. It's what we wanted in our game. There are lots of other ways to set elevation.

** TODO Controlling the distribution

If we have a desired distribution of elevations, we can reshape the distribution. I'm using a linear mapping from distance to elevation but that mapping can be anything.

* Rivers

At each corner, I can point to the corner that has the lowest elevation. This forms a drainage map, sometimes called a watershed map. Note that it follows some basic rules of rivers:

1. Rivers join together (tributaries) but don't fork (distributaries).
2. Rivers eventually reach the ocean.
3. There are no cycles.

The algorithm I'm using here produces poor results in the oceans. That's ok for now; I'm not using the values in the ocean in this project.

#+begin_export html
<div id="diagram-drainage-assignment">
  <figure>
    <figcaption>Drainage patterns</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,v_elevation,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="addRiver">Add river</button>
  <button v-on:click="addRiver25">Add 25</button>
  <button v-on:click="reset">Reset</button>
</div>
#+end_export

Drainage can be used for both watersheds and rivers, and both of those often form political boundaries. In this project I need rivers but not watersheds.

** TODO Lakes

** TODO Parameters for selecting a subset of rivers

* Moisture

I use a “moisture” value to assign biomes in the next section. I set moisture to the /distance/ from a river. The start points are the polygons adjacent to a river; they will have distance 0.

#+begin_export html
<div id="diagram-moisture-assignment">
  <figure>
    <figcaption>Drainage patterns</figcaption>
    <canvas width="600" height="600" v-draw="{show,mesh,v_water,v_ocean,v_moisture,t_downslope_e,river_t,e_flow}"/>
  </figure>
  <button v-on:click="addRiver10">Add rivers</button>
  <button v-on:click="reset">Reset</button>
</div>
#+end_export

If the river density is too low or too high the distribution isn't even.

There are many other ways to assign moisture/humidity/rainfall. I used this one because it was simple and worked well for the game these maps were for, but also consider using noise (Perlin, Simplex, etc.) or wind simulation (rain shadows, evapotranspiration, etc.).

** TODO Controlling the distribution

If we have a desired distribution of moisture, we can reshape the distribution. I'm using a sqrt mapping from distance to moisture but that mapping can be anything.

* Biomes

** TODO Controlling the distribution

See also http://worldengine-ecs.readthedocs.io/en/latest/biomes.html -- it seems useful to draw the scatter plot or a density plot, and then provide parameters for tuning that to make an ice world or a forest world etc.

* Noisy rendering

** Noisy edges

** Noisy transitions

** Noisy fills

* References

* More

#+begin_export html
  <x:footer>
    <script src="/js/vue.js"/>
    <script src="/js/prng.js"/>
    <script src="_bundle.js"/>

    Created 3 Aug 2017 with <a href="https://vue.org/">Vue.js</a> and Emacs org-mode (<a href="index.org">source of this page</a>); &#160;
    <!-- hhmts start -->Last modified: 10 Aug 2017<!-- hhmts end -->
  </x:footer>
#+end_export
